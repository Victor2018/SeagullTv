package com.victor.module;import android.content.Context;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import com.victor.interfaces.OnShakeListener;import java.util.List;public class ShakeManager {    private static ShakeManager sShakeManager;    private Context mContext;    private long mLastTime;    private float lastX;    private float lastY;    private float lastZ;    private long lastUpdateTime;    private static final int UPTATE_INTERVAL_TIME = 50;    private static final int SPEED_SHRESHOLD = 50;//这个值调节灵敏度    private OnShakeListener mOnShakeListener;    private ShakeManager(Context ctx) {        mContext = ctx;    }    public static ShakeManager with(Context ctx) {        if (sShakeManager == null                || sShakeManager.mContext == null) {            sShakeManager = new ShakeManager(ctx);        }        return sShakeManager;    }    private MySensor mySensor;    public void startShakeListener(OnShakeListener listener) {        mOnShakeListener = listener;        SensorManager sensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);        List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER);        if (sensorList.size() == 0) return;        Sensor sensor = sensorList.get(0);        mySensor = new MySensor();        sensorManager.registerListener(mySensor, sensor, SensorManager.SENSOR_DELAY_GAME);    }    private class MySensor implements SensorEventListener {        //传感器的数据发生变化会执行        @Override        public void onSensorChanged(SensorEvent event) {            /*if (mLastTime == 0l) {                //timestamp时间戳，就是很长的表示毫秒的一串数字                mLastTime = event.timestamp;                lastX = event.values[0];                lastY = event.values[1];                lastZ = event.values[2];            } else {                float x = event.values[0];                float y = event.values[1];                float z = event.values[2];                float force = Math.abs(x + y + z - lastX - lastY - lastZ);                if (iSensor != null) {                    iSensor.onSensorChange(force);                }                mLastTime = 0l;            }*/            long currentUpdateTime = System.currentTimeMillis();            long timeInterval = currentUpdateTime - lastUpdateTime;            if (timeInterval < UPTATE_INTERVAL_TIME) {                 return;            }            lastUpdateTime = currentUpdateTime;            // 传感器信息改变时执行该方法            float[] values = event.values;            float x = values[0]; // x轴方向的重力加速度，向右为正            float y = values[1]; // y轴方向的重力加速度，向前为正            float z = values[2]; // z轴方向的重力加速度，向上为正            float deltaX = x - lastX;            float deltaY = y - lastY;            float deltaZ = z - lastZ;            lastX = x;            lastY = y;            lastZ = z;            double speed = (Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ) / timeInterval) * 100;            if (speed >= SPEED_SHRESHOLD) {                if (mOnShakeListener != null) {                    mOnShakeListener.OnShake();                }            }        }        //当传感器的精确度改变会执行        @Override        public void onAccuracyChanged(Sensor sensor, int accuracy) {        }    }    public void cancel() {        SensorManager sensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);        //取消传感器监听        sensorManager.unregisterListener(mySensor);    }}